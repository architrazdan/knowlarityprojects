       # -*- coding: utf-8 -*-
       """
           jinja2._compat
           ~~~~~~~~~~~~~~
       
           Some py2/py3 compatibility support based on a stripped down
           version of six so we don't have to depend on a specific version
           of it.
       
           :copyright: Copyright 2013 by the Jinja team, see AUTHORS.
           :license: BSD, see LICENSE for details.
    1: """
    1: import sys
       
    1: PY2 = sys.version_info[0] == 2
    1: PYPY = hasattr(sys, 'pypy_translation_info')
    1: _identity = lambda x: x
       
       
    1: if not PY2:
           unichr = chr
           range_type = range
           text_type = str
           string_types = (str,)
           integer_types = (int,)
       
           iterkeys = lambda d: iter(d.keys())
           itervalues = lambda d: iter(d.values())
           iteritems = lambda d: iter(d.items())
       
           import pickle
           from io import BytesIO, StringIO
           NativeStringIO = StringIO
       
           def reraise(tp, value, tb=None):
               if value.__traceback__ is not tb:
                   raise value.with_traceback(tb)
               raise value
       
           ifilter = filter
           imap = map
           izip = zip
           intern = sys.intern
       
           implements_iterator = _identity
           implements_to_string = _identity
           encode_filename = _identity
           get_next = lambda x: x.__next__
       
       else:
    1:     unichr = unichr
    1:     text_type = unicode
    1:     range_type = xrange
    1:     string_types = (str, unicode)
    1:     integer_types = (int, long)
       
    1:     iterkeys = lambda d: d.iterkeys()
    1:     itervalues = lambda d: d.itervalues()
    2:     iteritems = lambda d: d.iteritems()
       
    1:     import cPickle as pickle
    1:     from cStringIO import StringIO as BytesIO, StringIO
    1:     NativeStringIO = BytesIO
       
    1:     exec('def reraise(tp, value, tb=None):\n raise tp, value, tb')
       
    1:     from itertools import imap, izip, ifilter
    1:     intern = intern
       
    1:     def implements_iterator(cls):
    5:         cls.next = cls.__next__
    5:         del cls.__next__
    5:         return cls
       
    1:     def implements_to_string(cls):
    6:         cls.__unicode__ = cls.__str__
    6:         cls.__str__ = lambda x: x.__unicode__().encode('utf-8')
    6:         return cls
       
    1:     get_next = lambda x: x.next
       
    1:     def encode_filename(filename):
               if isinstance(filename, unicode):
                   return filename.encode('utf-8')
               return filename
       
       
    1: def with_metaclass(meta, *bases):
           # This requires a bit of explanation: the basic idea is to make a
           # dummy metaclass for one level of class instanciation that replaces
           # itself with the actual metaclass.  Because of internal type checks
           # we also need to make sure that we downgrade the custom metaclass
           # for one level to something closer to type (that's why __call__ and
           # __init__ comes back from type etc.).
           #
           # This has the advantage over six.with_metaclass in that it does not
           # introduce dummy classes into the final MRO.
    2:     class metaclass(meta):
    1:         __call__ = type.__call__
    1:         __init__ = type.__init__
    1:         def __new__(cls, name, this_bases, d):
    2:             if this_bases is None:
    1:                 return type.__new__(cls, name, (), d)
    1:             return meta(name, bases, d)
    1:     return metaclass('temporary_class', None, {})
       
       
    1: try:
    1:     from urllib.parse import quote_from_bytes as url_quote
    1: except ImportError:
    1:     from urllib import quote as url_quote
