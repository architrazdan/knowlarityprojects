       # -*- coding: utf-8 -*-
       """
           jinja2.runtime
           ~~~~~~~~~~~~~~
       
           Runtime helpers.
       
           :copyright: (c) 2010 by the Jinja Team.
           :license: BSD.
    1: """
    1: import sys
       
    1: from itertools import chain
    1: from jinja2.nodes import EvalContext, _context_function_types
    1: from jinja2.utils import Markup, soft_unicode, escape, missing, concat, \
            internalcode, object_type_repr
    1: from jinja2.exceptions import UndefinedError, TemplateRuntimeError, \
            TemplateNotFound
    1: from jinja2._compat import imap, text_type, iteritems, \
            implements_iterator, implements_to_string, string_types, PY2
       
       
       # these variables are exported to the template runtime
    1: __all__ = ['LoopContext', 'TemplateReference', 'Macro', 'Markup',
    1:            'TemplateRuntimeError', 'missing', 'concat', 'escape',
    1:            'markup_join', 'unicode_join', 'to_string', 'identity',
    1:            'TemplateNotFound', 'make_logging_undefined']
       
       #: the name of the function that is used to convert something into
       #: a string.  We can just use the text type here.
    1: to_string = text_type
       
       #: the identity function.  Useful for certain things in the environment
    1: identity = lambda x: x
       
    1: _last_iteration = object()
       
       
    1: def markup_join(seq):
           """Concatenation that escapes if necessary and converts to unicode."""
           buf = []
           iterator = imap(soft_unicode, seq)
           for arg in iterator:
               buf.append(arg)
               if hasattr(arg, '__html__'):
                   return Markup(u'').join(chain(buf, iterator))
           return concat(buf)
       
       
    1: def unicode_join(seq):
           """Simple args to unicode conversion and concatenation."""
           return concat(imap(text_type, seq))
       
       
    1: def new_context(environment, template_name, blocks, vars=None,
    1:                 shared=None, globals=None, locals=None):
           """Internal helper to for context creation."""
           if vars is None:
               vars = {}
           if shared:
               parent = vars
           else:
               parent = dict(globals or (), **vars)
           if locals:
               # if the parent is shared a copy should be created because
               # we don't want to modify the dict passed
               if shared:
                   parent = dict(parent)
               for key, value in iteritems(locals):
                   if key[:2] == 'l_' and value is not missing:
                       parent[key[2:]] = value
           return environment.context_class(environment, parent, template_name,
                                            blocks)
       
       
    2: class TemplateReference(object):
    1:     """The `self` in templates."""
       
    1:     def __init__(self, context):
               self.__context = context
       
    1:     def __getitem__(self, name):
               blocks = self.__context.blocks[name]
               return BlockReference(name, self.__context, blocks, 0)
       
    1:     def __repr__(self):
               return '<%s %r>' % (
                   self.__class__.__name__,
                   self.__context.name
               )
       
       
    2: class Context(object):
           """The template context holds the variables of a template.  It stores the
           values passed to the template and also the names the template exports.
           Creating instances is neither supported nor useful as it's created
           automatically at various stages of the template evaluation and should not
           be created by hand.
       
           The context is immutable.  Modifications on :attr:`parent` **must not**
           happen and modifications on :attr:`vars` are allowed from generated
           template code only.  Template filters and global functions marked as
           :func:`contextfunction`\s get the active context passed as first argument
           and are allowed to access the context read-only.
       
           The template context supports read only dict operations (`get`,
           `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`,
           `__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve`
           method that doesn't fail with a `KeyError` but returns an
           :class:`Undefined` object for missing variables.
    1:     """
           __slots__ = ('parent', 'vars', 'environment', 'eval_ctx', 'exported_vars',
    1:                  'name', 'blocks', '__weakref__')
       
    1:     def __init__(self, environment, parent, name, blocks):
               self.parent = parent
               self.vars = {}
               self.environment = environment
               self.eval_ctx = EvalContext(self.environment, name)
               self.exported_vars = set()
               self.name = name
       
               # create the initial mapping of blocks.  Whenever template inheritance
               # takes place the runtime will update this mapping with the new blocks
               # from the template.
               self.blocks = dict((k, [v]) for k, v in iteritems(blocks))
       
    1:     def super(self, name, current):
               """Render a parent block."""
               try:
                   blocks = self.blocks[name]
                   index = blocks.index(current) + 1
                   blocks[index]
               except LookupError:
                   return self.environment.undefined('there is no parent block '
                                                     'called %r.' % name,
                                                     name='super')
               return BlockReference(name, self, blocks, index)
       
    1:     def get(self, key, default=None):
               """Returns an item from the template context, if it doesn't exist
               `default` is returned.
               """
               try:
                   return self[key]
               except KeyError:
                   return default
       
    1:     def resolve(self, key):
               """Looks up a variable like `__getitem__` or `get` but returns an
               :class:`Undefined` object with the name of the name looked up.
               """
               if key in self.vars:
                   return self.vars[key]
               if key in self.parent:
                   return self.parent[key]
               return self.environment.undefined(name=key)
       
    1:     def get_exported(self):
               """Get a new dict with the exported variables."""
               return dict((k, self.vars[k]) for k in self.exported_vars)
       
    1:     def get_all(self):
               """Return a copy of the complete context as dict including the
               exported variables.
               """
               return dict(self.parent, **self.vars)
       
    1:     @internalcode
           def call(__self, __obj, *args, **kwargs):
               """Call the callable with the arguments and keyword arguments
               provided but inject the active context or environment as first
               argument if the callable is a :func:`contextfunction` or
               :func:`environmentfunction`.
               """
               if __debug__:
                   __traceback_hide__ = True  # noqa
       
               # Allow callable classes to take a context
               fn = __obj.__call__
               for fn_type in ('contextfunction',
                               'evalcontextfunction',
                               'environmentfunction'):
                   if hasattr(fn, fn_type):
                       __obj = fn
                       break
       
               if isinstance(__obj, _context_function_types):
                   if getattr(__obj, 'contextfunction', 0):
                       args = (__self,) + args
                   elif getattr(__obj, 'evalcontextfunction', 0):
                       args = (__self.eval_ctx,) + args
                   elif getattr(__obj, 'environmentfunction', 0):
                       args = (__self.environment,) + args
               try:
                   return __obj(*args, **kwargs)
               except StopIteration:
                   return __self.environment.undefined('value was undefined because '
                                                       'a callable raised a '
                                                       'StopIteration exception')
       
    1:     def derived(self, locals=None):
               """Internal helper function to create a derived context."""
               context = new_context(self.environment, self.name, {},
                                     self.parent, True, None, locals)
               context.vars.update(self.vars)
               context.eval_ctx = self.eval_ctx
               context.blocks.update((k, list(v)) for k, v in iteritems(self.blocks))
               return context
       
    1:     def _all(meth):
    6:         proxy = lambda self: getattr(self.get_all(), meth)()
    6:         proxy.__doc__ = getattr(dict, meth).__doc__
    6:         proxy.__name__ = meth
    6:         return proxy
       
    1:     keys = _all('keys')
    1:     values = _all('values')
    1:     items = _all('items')
       
           # not available on python 3
    1:     if PY2:
    1:         iterkeys = _all('iterkeys')
    1:         itervalues = _all('itervalues')
    1:         iteritems = _all('iteritems')
    1:     del _all
       
    1:     def __contains__(self, name):
               return name in self.vars or name in self.parent
       
    1:     def __getitem__(self, key):
               """Lookup a variable or raise `KeyError` if the variable is
               undefined.
               """
               item = self.resolve(key)
               if isinstance(item, Undefined):
                   raise KeyError(key)
               return item
       
    1:     def __repr__(self):
               return '<%s %s of %r>' % (
                   self.__class__.__name__,
                   repr(self.get_all()),
                   self.name
               )
       
       
       # register the context as mapping if possible
    1: try:
    1:     from collections import Mapping
    1:     Mapping.register(Context)
       except ImportError:
           pass
       
       
    2: class BlockReference(object):
    1:     """One block on a template reference."""
       
    1:     def __init__(self, name, context, stack, depth):
               self.name = name
               self._context = context
               self._stack = stack
               self._depth = depth
       
    1:     @property
           def super(self):
               """Super the block."""
               if self._depth + 1 >= len(self._stack):
                   return self._context.environment. \
                       undefined('there is no parent block called %r.' %
                                 self.name, name='super')
               return BlockReference(self.name, self._context, self._stack,
                                     self._depth + 1)
       
    1:     @internalcode
           def __call__(self):
               rv = concat(self._stack[self._depth](self._context))
               if self._context.eval_ctx.autoescape:
                   rv = Markup(rv)
               return rv
       
       
    2: class LoopContext(object):
    1:     """A loop context for dynamic iteration."""
       
    1:     def __init__(self, iterable, recurse=None, depth0=0):
               self._iterator = iter(iterable)
               self._recurse = recurse
               self._after = self._safe_next()
               self.index0 = -1
               self.depth0 = depth0
       
               # try to get the length of the iterable early.  This must be done
               # here because there are some broken iterators around where there
               # __len__ is the number of iterations left (i'm looking at your
               # listreverseiterator!).
               try:
                   self._length = len(iterable)
               except (TypeError, AttributeError):
                   self._length = None
       
    1:     def cycle(self, *args):
               """Cycles among the arguments with the current loop index."""
               if not args:
                   raise TypeError('no items for cycling given')
               return args[self.index0 % len(args)]
       
    1:     first = property(lambda x: x.index0 == 0)
    1:     last = property(lambda x: x._after is _last_iteration)
    1:     index = property(lambda x: x.index0 + 1)
    1:     revindex = property(lambda x: x.length - x.index0)
    1:     revindex0 = property(lambda x: x.length - x.index)
    1:     depth = property(lambda x: x.depth0 + 1)
       
    1:     def __len__(self):
               return self.length
       
    1:     def __iter__(self):
               return LoopContextIterator(self)
       
    1:     def _safe_next(self):
               try:
                   return next(self._iterator)
               except StopIteration:
                   return _last_iteration
       
    1:     @internalcode
           def loop(self, iterable):
               if self._recurse is None:
                   raise TypeError('Tried to call non recursive loop.  Maybe you '
                                   "forgot the 'recursive' modifier.")
               return self._recurse(iterable, self._recurse, self.depth0 + 1)
       
           # a nifty trick to enhance the error message if someone tried to call
           # the the loop without or with too many arguments.
    1:     __call__ = loop
    1:     del loop
       
    1:     @property
           def length(self):
               if self._length is None:
                   # if was not possible to get the length of the iterator when
                   # the loop context was created (ie: iterating over a generator)
                   # we have to convert the iterable into a sequence and use the
                   # length of that + the number of iterations so far.
                   iterable = tuple(self._iterator)
                   self._iterator = iter(iterable)
                   iterations_done = self.index0 + 2
                   self._length = len(iterable) + iterations_done
               return self._length
       
    1:     def __repr__(self):
               return '<%s %r/%r>' % (
                   self.__class__.__name__,
                   self.index,
                   self.length
               )
       
       
    2: @implements_iterator
    1: class LoopContextIterator(object):
    1:     """The iterator for a loop context."""
    1:     __slots__ = ('context',)
       
    1:     def __init__(self, context):
               self.context = context
       
    1:     def __iter__(self):
               return self
       
    1:     def __next__(self):
               ctx = self.context
               ctx.index0 += 1
               if ctx._after is _last_iteration:
                   raise StopIteration()
               next_elem = ctx._after
               ctx._after = ctx._safe_next()
               return next_elem, ctx
       
       
    2: class Macro(object):
    1:     """Wraps a macro function."""
       
    1:     def __init__(self, environment, func, name, arguments, defaults,
                        catch_kwargs, catch_varargs, caller):
               self._environment = environment
               self._func = func
               self._argument_count = len(arguments)
               self.name = name
               self.arguments = arguments
               self.defaults = defaults
               self.catch_kwargs = catch_kwargs
               self.catch_varargs = catch_varargs
               self.caller = caller
       
    1:     @internalcode
           def __call__(self, *args, **kwargs):
               # try to consume the positional arguments
               arguments = list(args[:self._argument_count])
               off = len(arguments)
       
               # if the number of arguments consumed is not the number of
               # arguments expected we start filling in keyword arguments
               # and defaults.
               if off != self._argument_count:
                   for idx, name in enumerate(self.arguments[len(arguments):]):
                       try:
                           value = kwargs.pop(name)
                       except KeyError:
                           try:
                               value = self.defaults[idx - self._argument_count + off]
                           except IndexError:
                               value = self._environment.undefined(
                                   'parameter %r was not provided' % name, name=name)
                       arguments.append(value)
       
               # it's important that the order of these arguments does not change
               # if not also changed in the compiler's `function_scoping` method.
               # the order is caller, keyword arguments, positional arguments!
               if self.caller:
                   caller = kwargs.pop('caller', None)
                   if caller is None:
                       caller = self._environment.undefined('No caller defined',
                                                            name='caller')
                   arguments.append(caller)
               if self.catch_kwargs:
                   arguments.append(kwargs)
               elif kwargs:
                   raise TypeError('macro %r takes no keyword argument %r' %
                                   (self.name, next(iter(kwargs))))
               if self.catch_varargs:
                   arguments.append(args[self._argument_count:])
               elif len(args) > self._argument_count:
                   raise TypeError('macro %r takes not more than %d argument(s)' %
                                   (self.name, len(self.arguments)))
               return self._func(*arguments)
       
    1:     def __repr__(self):
               return '<%s %s>' % (
                   self.__class__.__name__,
                   self.name is None and 'anonymous' or repr(self.name)
               )
       
       
    2: @implements_to_string
    1: class Undefined(object):
           """The default undefined type.  This undefined type can be printed and
           iterated over, but every other access will raise an :exc:`jinja2.exceptions.UndefinedError`:
       
           >>> foo = Undefined(name='foo')
           >>> str(foo)
           ''
           >>> not foo
           True
           >>> foo + 42
           Traceback (most recent call last):
             ...
           jinja2.exceptions.UndefinedError: 'foo' is undefined
    1:     """
           __slots__ = ('_undefined_hint', '_undefined_obj', '_undefined_name',
    1:                  '_undefined_exception')
       
    1:     def __init__(self, hint=None, obj=missing, name=None, exc=UndefinedError):
               self._undefined_hint = hint
               self._undefined_obj = obj
               self._undefined_name = name
               self._undefined_exception = exc
       
    1:     @internalcode
           def _fail_with_undefined_error(self, *args, **kwargs):
               """Regular callback function for undefined objects that raises an
               `jinja2.exceptions.UndefinedError` on call.
               """
               if self._undefined_hint is None:
                   if self._undefined_obj is missing:
                       hint = '%r is undefined' % self._undefined_name
                   elif not isinstance(self._undefined_name, string_types):
                       hint = '%s has no element %r' % (
                           object_type_repr(self._undefined_obj),
                           self._undefined_name
                       )
                   else:
                       hint = '%r has no attribute %r' % (
                           object_type_repr(self._undefined_obj),
                           self._undefined_name
                       )
               else:
                   hint = self._undefined_hint
               raise self._undefined_exception(hint)
       
    1:     @internalcode
           def __getattr__(self, name):
               if name[:2] == '__':
                   raise AttributeError(name)
               return self._fail_with_undefined_error()
       
           __add__ = __radd__ = __mul__ = __rmul__ = __div__ = __rdiv__ = \
               __truediv__ = __rtruediv__ = __floordiv__ = __rfloordiv__ = \
               __mod__ = __rmod__ = __pos__ = __neg__ = __call__ = \
               __getitem__ = __lt__ = __le__ = __gt__ = __ge__ = __int__ = \
               __float__ = __complex__ = __pow__ = __rpow__ = \
    1:         _fail_with_undefined_error
       
    1:     def __eq__(self, other):
               return type(self) is type(other)
       
    1:     def __ne__(self, other):
               return not self.__eq__(other)
       
    1:     def __hash__(self):
               return id(type(self))
       
    1:     def __str__(self):
               return u''
       
    1:     def __len__(self):
               return 0
       
    1:     def __iter__(self):
               if 0:
                   yield None
       
    1:     def __nonzero__(self):
               return False
    1:     __bool__ = __nonzero__
       
    1:     def __repr__(self):
               return 'Undefined'
       
       
    1: def make_logging_undefined(logger=None, base=None):
           """Given a logger object this returns a new undefined class that will
           log certain failures.  It will log iterations and printing.  If no
           logger is given a default logger is created.
       
           Example::
       
               logger = logging.getLogger(__name__)
               LoggingUndefined = make_logging_undefined(
                   logger=logger,
                   base=Undefined
               )
       
           .. versionadded:: 2.8
       
           :param logger: the logger to use.  If not provided, a default logger
                          is created.
           :param base: the base class to add logging functionality to.  This
                        defaults to :class:`Undefined`.
           """
           if logger is None:
               import logging
               logger = logging.getLogger(__name__)
               logger.addHandler(logging.StreamHandler(sys.stderr))
           if base is None:
               base = Undefined
       
           def _log_message(undef):
               if undef._undefined_hint is None:
                   if undef._undefined_obj is missing:
                       hint = '%s is undefined' % undef._undefined_name
                   elif not isinstance(undef._undefined_name, string_types):
                       hint = '%s has no element %s' % (
                           object_type_repr(undef._undefined_obj),
                           undef._undefined_name)
                   else:
                       hint = '%s has no attribute %s' % (
                           object_type_repr(undef._undefined_obj),
                           undef._undefined_name)
               else:
                   hint = undef._undefined_hint
               logger.warning('Template variable warning: %s', hint)
       
           class LoggingUndefined(base):
       
               def _fail_with_undefined_error(self, *args, **kwargs):
                   try:
                       return base._fail_with_undefined_error(self, *args, **kwargs)
                   except self._undefined_exception as e:
                       logger.error('Template variable error: %s', str(e))
                       raise e
       
               def __str__(self):
                   rv = base.__str__(self)
                   _log_message(self)
                   return rv
       
               def __iter__(self):
                   rv = base.__iter__(self)
                   _log_message(self)
                   return rv
       
               if PY2:
                   def __nonzero__(self):
                       rv = base.__nonzero__(self)
                       _log_message(self)
                       return rv
       
                   def __unicode__(self):
                       rv = base.__unicode__(self)
                       _log_message(self)
                       return rv
               else:
                   def __bool__(self):
                       rv = base.__bool__(self)
                       _log_message(self)
                       return rv
       
           return LoggingUndefined
       
       
    2: @implements_to_string
    1: class DebugUndefined(Undefined):
           """An undefined that returns the debug info when printed.
       
           >>> foo = DebugUndefined(name='foo')
           >>> str(foo)
           '{{ foo }}'
           >>> not foo
           True
           >>> foo + 42
           Traceback (most recent call last):
             ...
           jinja2.exceptions.UndefinedError: 'foo' is undefined
    1:     """
    1:     __slots__ = ()
       
    1:     def __str__(self):
               if self._undefined_hint is None:
                   if self._undefined_obj is missing:
                       return u'{{ %s }}' % self._undefined_name
                   return '{{ no such element: %s[%r] }}' % (
                       object_type_repr(self._undefined_obj),
                       self._undefined_name
                   )
               return u'{{ undefined value printed: %s }}' % self._undefined_hint
       
       
    2: @implements_to_string
    1: class StrictUndefined(Undefined):
           """An undefined that barks on print and iteration as well as boolean
           tests and all kinds of comparisons.  In other words: you can do nothing
           with it except checking if it's defined using the `defined` test.
       
           >>> foo = StrictUndefined(name='foo')
           >>> str(foo)
           Traceback (most recent call last):
             ...
           jinja2.exceptions.UndefinedError: 'foo' is undefined
           >>> not foo
           Traceback (most recent call last):
             ...
           jinja2.exceptions.UndefinedError: 'foo' is undefined
           >>> foo + 42
           Traceback (most recent call last):
             ...
           jinja2.exceptions.UndefinedError: 'foo' is undefined
    1:     """
    1:     __slots__ = ()
           __iter__ = __str__ = __len__ = __nonzero__ = __eq__ = \
               __ne__ = __bool__ = __hash__ = \
    1:         Undefined._fail_with_undefined_error
       
       
       # remove remaining slots attributes, after the metaclass did the magic they
       # are unneeded and irritating as they contain wrong data for the subclasses.
    1: del Undefined.__slots__, DebugUndefined.__slots__, StrictUndefined.__slots__
