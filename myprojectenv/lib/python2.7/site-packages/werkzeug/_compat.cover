       # flake8: noqa
       # This whole file is full of lint errors
    1: import codecs
    1: import sys
    1: import operator
    1: import functools
    1: import warnings
       
    1: try:
    1:     import builtins
    1: except ImportError:
    1:     import __builtin__ as builtins
       
       
    1: PY2 = sys.version_info[0] == 2
    1: WIN = sys.platform.startswith('win')
       
   41: _identity = lambda x: x
       
    1: if PY2:
    1:     unichr = unichr
    1:     text_type = unicode
    1:     string_types = (str, unicode)
    1:     integer_types = (int, long)
       
    1:     iterkeys = lambda d, *args, **kwargs: d.iterkeys(*args, **kwargs)
    2:     itervalues = lambda d, *args, **kwargs: d.itervalues(*args, **kwargs)
   16:     iteritems = lambda d, *args, **kwargs: d.iteritems(*args, **kwargs)
       
    1:     iterlists = lambda d, *args, **kwargs: d.iterlists(*args, **kwargs)
    1:     iterlistvalues = lambda d, *args, **kwargs: d.iterlistvalues(*args, **kwargs)
       
    1:     int_to_byte = chr
    1:     iter_bytes = iter
       
    1:     exec('def reraise(tp, value, tb=None):\n raise tp, value, tb')
       
    1:     def fix_tuple_repr(obj):
    1:         def __repr__(self):
                   cls = self.__class__
                   return '%s(%s)' % (cls.__name__, ', '.join(
                       '%s=%r' % (field, self[index])
                       for index, field in enumerate(cls._fields)
                   ))
    1:         obj.__repr__ = __repr__
    1:         return obj
       
    1:     def implements_iterator(cls):
    3:         cls.next = cls.__next__
    3:         del cls.__next__
    3:         return cls
       
    1:     def implements_to_string(cls):
    3:         cls.__unicode__ = cls.__str__
    3:         cls.__str__ = lambda x: x.__unicode__().encode('utf-8')
    3:         return cls
       
    1:     def native_string_result(func):
    1:         def wrapper(*args, **kwargs):
                   return func(*args, **kwargs).encode('utf-8')
    1:         return functools.update_wrapper(wrapper, func)
       
    1:     def implements_bool(cls):
    1:         cls.__nonzero__ = cls.__bool__
    1:         del cls.__bool__
    1:         return cls
       
    1:     from itertools import imap, izip, ifilter
    1:     range_type = xrange
       
    1:     from StringIO import StringIO
    1:     from cStringIO import StringIO as BytesIO
    1:     NativeStringIO = BytesIO
       
    1:     def make_literal_wrapper(reference):
    5:         return _identity
       
    1:     def normalize_string_tuple(tup):
               """Normalizes a string tuple to a common type. Following Python 2
               rules, upgrades to unicode are implicit.
               """
               if any(isinstance(x, text_type) for x in tup):
                   return tuple(to_unicode(x) for x in tup)
               return tup
       
    1:     def try_coerce_native(s):
               """Try to coerce a unicode string to native if possible. Otherwise,
               leave it as unicode.
               """
               try:
                   return to_native(s)
               except UnicodeError:
                   return s
       
    1:     wsgi_get_bytes = _identity
       
    1:     def wsgi_decoding_dance(s, charset='utf-8', errors='replace'):
   19:         return s.decode(charset, errors)
       
    1:     def wsgi_encoding_dance(s, charset='utf-8', errors='replace'):
   10:         if isinstance(s, bytes):
    5:             return s
    5:         return s.encode(charset, errors)
       
    1:     def to_bytes(x, charset=sys.getdefaultencoding(), errors='strict'):
               if x is None:
                   return None
               if isinstance(x, (bytes, bytearray, buffer)):
                   return bytes(x)
               if isinstance(x, unicode):
                   return x.encode(charset, errors)
               raise TypeError('Expected bytes')
       
    1:     def to_native(x, charset=sys.getdefaultencoding(), errors='strict'):
   22:         if x is None or isinstance(x, str):
   22:             return x
               return x.encode(charset, errors)
       
       else:
           unichr = chr
           text_type = str
           string_types = (str, )
           integer_types = (int, )
       
           iterkeys = lambda d, *args, **kwargs: iter(d.keys(*args, **kwargs))
           itervalues = lambda d, *args, **kwargs: iter(d.values(*args, **kwargs))
           iteritems = lambda d, *args, **kwargs: iter(d.items(*args, **kwargs))
       
           iterlists = lambda d, *args, **kwargs: iter(d.lists(*args, **kwargs))
           iterlistvalues = lambda d, *args, **kwargs: iter(d.listvalues(*args, **kwargs))
       
           int_to_byte = operator.methodcaller('to_bytes', 1, 'big')
           iter_bytes = functools.partial(map, int_to_byte)
       
           def reraise(tp, value, tb=None):
               if value.__traceback__ is not tb:
                   raise value.with_traceback(tb)
               raise value
       
           fix_tuple_repr = _identity
           implements_iterator = _identity
           implements_to_string = _identity
           implements_bool = _identity
           native_string_result = _identity
           imap = map
           izip = zip
           ifilter = filter
           range_type = range
       
           from io import StringIO, BytesIO
           NativeStringIO = StringIO
       
           _latin1_encode = operator.methodcaller('encode', 'latin1')
       
           def make_literal_wrapper(reference):
               if isinstance(reference, text_type):
                   return _identity
               return _latin1_encode
       
           def normalize_string_tuple(tup):
               """Ensures that all types in the tuple are either strings
               or bytes.
               """
               tupiter = iter(tup)
               is_text = isinstance(next(tupiter, None), text_type)
               for arg in tupiter:
                   if isinstance(arg, text_type) != is_text:
                       raise TypeError('Cannot mix str and bytes arguments (got %s)'
                                       % repr(tup))
               return tup
       
           try_coerce_native = _identity
           wsgi_get_bytes = _latin1_encode
       
           def wsgi_decoding_dance(s, charset='utf-8', errors='replace'):
               return s.encode('latin1').decode(charset, errors)
       
           def wsgi_encoding_dance(s, charset='utf-8', errors='replace'):
               if isinstance(s, text_type):
                   s = s.encode(charset)
               return s.decode('latin1', errors)
       
           def to_bytes(x, charset=sys.getdefaultencoding(), errors='strict'):
               if x is None:
                   return None
               if isinstance(x, (bytes, bytearray, memoryview)):  # noqa
                   return bytes(x)
               if isinstance(x, str):
                   return x.encode(charset, errors)
               raise TypeError('Expected bytes')
       
           def to_native(x, charset=sys.getdefaultencoding(), errors='strict'):
               if x is None or isinstance(x, str):
                   return x
               return x.decode(charset, errors)
       
       
    1: def to_unicode(x, charset=sys.getdefaultencoding(), errors='strict',
    1:                allow_none_charset=False):
   30:     if x is None:
               return None
   30:     if not isinstance(x, bytes):
   10:         return text_type(x)
   20:     if charset is None and allow_none_charset:
               return x
   20:     return x.decode(charset, errors)
