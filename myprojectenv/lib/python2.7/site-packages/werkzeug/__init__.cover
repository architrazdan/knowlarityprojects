       # -*- coding: utf-8 -*-
       """
           werkzeug
           ~~~~~~~~
       
           Werkzeug is the Swiss Army knife of Python web development.
       
           It provides useful classes and functions for any WSGI application to make
           the life of a python web developer much easier.  All of the provided
           classes are independent from each other so you can mix it with any other
           library.
       
       
           :copyright: (c) 2014 by the Werkzeug Team, see AUTHORS for more details.
           :license: BSD, see LICENSE for more details.
    1: """
    1: from types import ModuleType
    1: import sys
       
    1: from werkzeug._compat import iteritems
       
       # the version.  Usually set automatically by a script.
    1: __version__ = '0.11.9'
       
       
       # This import magic raises concerns quite often which is why the implementation
       # and motivation is explained here in detail now.
       #
       # The majority of the functions and classes provided by Werkzeug work on the
       # HTTP and WSGI layer.  There is no useful grouping for those which is why
       # they are all importable from "werkzeug" instead of the modules where they are
       # implemented.  The downside of that is, that now everything would be loaded at
       # once, even if unused.
       #
       # The implementation of a lazy-loading module in this file replaces the
       # werkzeug package when imported from within.  Attribute access to the werkzeug
       # module will then lazily import from the modules that implement the objects.
       
       
       # import mapping to objects in other modules
    1: all_by_module = {
    1:     'werkzeug.debug': ['DebuggedApplication'],
    1:     'werkzeug.local': ['Local', 'LocalManager', 'LocalProxy', 'LocalStack',
    1:                        'release_local'],
    1:     'werkzeug.serving': ['run_simple'],
    1:     'werkzeug.test': ['Client', 'EnvironBuilder', 'create_environ',
    1:                       'run_wsgi_app'],
    1:     'werkzeug.testapp': ['test_app'],
    1:     'werkzeug.exceptions': ['abort', 'Aborter'],
    1:     'werkzeug.urls': ['url_decode', 'url_encode', 'url_quote',
    1:                       'url_quote_plus', 'url_unquote', 'url_unquote_plus',
    1:                       'url_fix', 'Href', 'iri_to_uri', 'uri_to_iri'],
    1:     'werkzeug.formparser': ['parse_form_data'],
    1:     'werkzeug.utils': ['escape', 'environ_property', 'append_slash_redirect',
    1:                        'redirect', 'cached_property', 'import_string',
    1:                        'dump_cookie', 'parse_cookie', 'unescape',
    1:                        'format_string', 'find_modules', 'header_property',
    1:                        'html', 'xhtml', 'HTMLBuilder', 'validate_arguments',
    1:                        'ArgumentValidationError', 'bind_arguments',
    1:                        'secure_filename'],
    1:     'werkzeug.wsgi': ['get_current_url', 'get_host', 'pop_path_info',
    1:                       'peek_path_info', 'SharedDataMiddleware',
    1:                       'DispatcherMiddleware', 'ClosingIterator', 'FileWrapper',
    1:                       'make_line_iter', 'LimitedStream', 'responder',
    1:                       'wrap_file', 'extract_path_info'],
    1:     'werkzeug.datastructures': ['MultiDict', 'CombinedMultiDict', 'Headers',
    1:                                 'EnvironHeaders', 'ImmutableList',
    1:                                 'ImmutableDict', 'ImmutableMultiDict',
    1:                                 'TypeConversionDict',
    1:                                 'ImmutableTypeConversionDict', 'Accept',
    1:                                 'MIMEAccept', 'CharsetAccept',
    1:                                 'LanguageAccept', 'RequestCacheControl',
    1:                                 'ResponseCacheControl', 'ETags', 'HeaderSet',
    1:                                 'WWWAuthenticate', 'Authorization',
    1:                                 'FileMultiDict', 'CallbackDict', 'FileStorage',
    1:                                 'OrderedMultiDict', 'ImmutableOrderedMultiDict'
                                       ],
    1:     'werkzeug.useragents':  ['UserAgent'],
    1:     'werkzeug.http': ['parse_etags', 'parse_date', 'http_date', 'cookie_date',
    1:                       'parse_cache_control_header', 'is_resource_modified',
    1:                       'parse_accept_header', 'parse_set_header', 'quote_etag',
    1:                       'unquote_etag', 'generate_etag', 'dump_header',
    1:                       'parse_list_header', 'parse_dict_header',
    1:                       'parse_authorization_header',
    1:                       'parse_www_authenticate_header', 'remove_entity_headers',
    1:                       'is_entity_header', 'remove_hop_by_hop_headers',
    1:                       'parse_options_header', 'dump_options_header',
    1:                       'is_hop_by_hop_header', 'unquote_header_value',
    1:                       'quote_header_value', 'HTTP_STATUS_CODES'],
    1:     'werkzeug.wrappers': ['BaseResponse', 'BaseRequest', 'Request', 'Response',
    1:                           'AcceptMixin', 'ETagRequestMixin',
    1:                           'ETagResponseMixin', 'ResponseStreamMixin',
    1:                           'CommonResponseDescriptorsMixin', 'UserAgentMixin',
    1:                           'AuthorizationMixin', 'WWWAuthenticateMixin',
    1:                           'CommonRequestDescriptorsMixin'],
    1:     'werkzeug.security': ['generate_password_hash', 'check_password_hash'],
           # the undocumented easteregg ;-)
    1:     'werkzeug._internal': ['_easteregg']
       }
       
       # modules that should be imported when accessed as attributes of werkzeug
    1: attribute_modules = frozenset(['exceptions', 'routing', 'script'])
       
       
    1: object_origins = {}
   17: for module, items in iteritems(all_by_module):
  139:     for item in items:
  123:         object_origins[item] = module
       
       
    2: class module(ModuleType):
       
    1:     """Automatically import objects from the modules."""
       
    1:     def __getattr__(self, name):
    1:         if name in object_origins:
                   module = __import__(object_origins[name], None, None, [name])
                   for extra_name in all_by_module[module.__name__]:
                       setattr(self, extra_name, getattr(module, extra_name))
                   return getattr(module, name)
    1:         elif name in attribute_modules:
                   __import__('werkzeug.' + name)
    1:         return ModuleType.__getattribute__(self, name)
       
    1:     def __dir__(self):
               """Just show what we want to show."""
               result = list(new_module.__all__)
               result.extend(('__file__', '__path__', '__doc__', '__all__',
                              '__docformat__', '__name__', '__path__',
                              '__package__', '__version__'))
               return result
       
       # keep a reference to this module so that it's not garbage collected
    1: old_module = sys.modules['werkzeug']
       
       
       # setup the new module and patch it into the dict of loaded modules
    1: new_module = sys.modules['werkzeug'] = module('werkzeug')
    1: new_module.__dict__.update({
    1:     '__file__':         __file__,
    1:     '__package__':      'werkzeug',
    1:     '__path__':         __path__,
    1:     '__doc__':          __doc__,
    1:     '__version__':      __version__,
    1:     '__all__':          tuple(object_origins) + tuple(attribute_modules),
    1:     '__docformat__':    'restructuredtext en'
       })
       
       
       # Due to bootstrapping issues we need to import exceptions here.
       # Don't ask :-(
    1: __import__('werkzeug.exceptions')
